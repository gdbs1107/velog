<h1 id="1-배경">1. 배경</h1>
<p>최근 볼래말래를 포함한 다양한 프로젝트에서 서버 파트를 맡아 개발하며 몇가지 고민이 존재하였다.</p>
<br />

<h3 id="정확히-어떤-uri-포트로-접근해야-서버에-접근이-가능한지-불명확함">정확히 어떤 URI, 포트로 접근해야 서버에 접근이 가능한지 불명확함</h3>
<p>볼래말래의 경우, 프론트 단에서도 https가 구현이 되어서 https - https 간의 통신이 원활하게 진행되었다. 하지만 서버에서 grafana에 접근하기 위해선</p>
<p><code>http://IP주소/{그라파나 포트}</code></p>
<p>로만 접근이 되고 도메인을 탄다거나, https로 접근을 요청하면 모두 접근이 되지 않는 문제가 발생하였다. 또한 같이 병행중인 다른 프로젝트에서는 http로만 api요청이 가능하고 https로 접근하면 요청이 수락되지 않는다는 문의가 존재하였다.</p>
<p><img alt="" src="https://velog.velcdn.com/images/gdbs1107/post/aa125425-2fa0-40ce-8f5c-f2691791fd8a/image.png" /></p>
<p>이유를 알고 그 이유가 당장 해결이 불가능한 문제라면 차라리 다행이지만, <strong>난 문제도 제대로 파악할 수 없는 수준이었다.</strong></p>
<br />

<h3 id="nginx">NGINX</h3>
<p>최근 NGINX에 대한 의구심이 갈수록 커져갔다.</p>
<p>이전에 진행한 프로젝트에선 NGINX를 이용한 리버스 프록시를 습관처럼 적용하였다. 그러다 문득 볼래말래를 시작할때, 왜 NGINX가 필요한가에 대해 의심을 하기 시작했다.</p>
<br />

<p>NGINX의 장점으로는 빠른 정적호스팅, 서버 로드밸런싱과 리버스 프록시, SSL인증을 통한 https 통신 구현이 가능하다라는 점 등이 장점이 있다고 생각한다.</p>
<p>하지만 이 중 정적호스팅을 제외하고는 모두 AWS ALB에서 구현이 가능한 부분이 아닌가? 그래서 실제로 볼래말래에서 NGINX가 아닌 내장 아파치 톰캣서버로 구현을 하였고 아직까지는 큰 문제가 없었다. 실제로 몇몇 웹사이트를 찾아봐도 NGINX를 굳이 구현하지 않아도 아파치 만으로도 충분할 정도로 아파치의 개발성능이 많이 증가했다는 글을 찾아 볼 수 있었다.
<br /></p>
<p>과연 NGINX는 필요한 것일까?</p>
<br />

<h3 id="무중단-배포">무중단 배포</h3>
<p>무중단 배포는 다른 프로젝트에서 AWS Elastic Beanstalk를 이용하여 구현을 해본 경험이 있었다. CICD 파이프라인을 EB로 처음 접한 탓에 무중단 배포는 나에게는 너무 당연한 것이었지만, 최근에는 굳이 필요한가라는 생각이 들고 있었다.</p>
<br />

<p>하지만 볼래말래를 구현하던 중, 프론트와 연동을 할 때 서버가 무거워져서일까? 서버 재가동 시간이 깃허브 빌드를 포함하여 7분에 달하는 정도로 이르렀다. 바로바로 문제점을 반영해야하는 상황에서 긴 서버 다운타임은 우리에게 꽤나 부담이었고 이를 위해 무중단 배포를 구현하려 하였다.</p>
<p>하지만 EB로 서버를 리팩터링하기에는 이미 서버에 구축해놓은 자원이 너무 많았다. 그렇기 때문에 우리는 현재 서버를 유지하며 NGINX와 도커 컴포즈만 수정하여 서버에 두개의 포트를 띄워 무중단배포를 구현하는 blue/green 배포를 구현하도록 결정하였다.</p>
<br />


<p>이러한 점 때문에 NGINX가 가용되는 것이구나 라고 생각하였다. 로드밸런싱을 ALB보다 유연하게 할 수 있고, 무엇보다 현재 ALB에 과하게 부여된 책임 (로드밸런싱, https, 도메인 등) 을 NGINX와 분할하여 부담하도록 하면 서버가 보다 원활해질 것이라는 생각을 하게 되었다.</p>
<p><img alt="" src="https://velog.velcdn.com/images/gdbs1107/post/aeb234e8-d678-416f-832d-4f014c31a83d/image.png" /></p>
<p>그러면 NGINX와 포트 문제만 해결하면 될 것 같은데….NGINX도 잘 모르고 그와 함께 사용되는 ALB와의 상호작용도 잘 모르며 구현에만 집착한 나머지 이렇게 많이 진행된 서버를 리팩터링 하려고 하니까 걱정이 많았다.</p>
<p>그래서 NGINX 부터 다시 정리하며 천천히 무중단배포까지 구현하기로 결정을 하였다.</p>
<hr />
<p><br /><br /></p>
<h1 id="2-nginx의-정적호스팅">2. NGINX의 정적호스팅</h1>
<p>NGINX에서 정적호스팅을 하기 위해선 우선 서버에 nginx를 설치해주어야한다.</p>
<p>서버에 설치를 하고 나면</p>
<p><code>sites-avaliable</code></p>
<p><code>sites-enable</code></p>
<p><code>nginx.conf</code></p>
<p>이 세가지의 주요 파일이 설치된다.</p>
<p>각각 설명을 해보자면 sites-avalidable의 경우 <strong>가상 호스트 설정 파일을 저장하는 디렉터리이고</strong></p>
<p>sites-enable는 <strong>실제로 활성화된 사이트 설정이 포함된 디렉터리이다.</strong></p>
<p>이들을 서로 링크해주기 위한 파일이 nginx.conf 이기 때문에</p>
<p>내가 배운대로는 nginx.conf에서 작업을 진행하기 보단, 위의 두 파일을 수정하는게 더 안전하다고 판단하였다.</p>
<br />


<p>해서 sites-avalidable/default로 접근하면</p>
<pre><code class="language-java">##
# You should look at the following URL's in order to grasp a solid understanding
# of Nginx configuration files in order to fully unleash the power of Nginx.
# https://www.nginx.com/resources/wiki/start/
# https://www.nginx.com/resources/wiki/start/topics/tutorials/config_pitfalls/
# https://wiki.debian.org/Nginx/DirectoryStructure
#
# In most cases, administrators will remove this file from sites-enabled/ and
# leave it as reference inside of sites-available where it will continue to be
# updated by the nginx packaging team.
#
# This file will automatically load configuration files provided by other
# applications, such as Drupal or Wordpress. These applications will be made
# available underneath a path with that package name, such as /drupal8.
#
# Please see /usr/share/doc/nginx-doc/examples/ for more detailed examples.
##

# Default server configuration
#
server {
        listen 80 default_server;
        listen [::]:80 default_server;

        # SSL configuration
        #
        # listen 443 ssl default_server;
        # listen [::]:443 ssl default_server;
        #
        # Note: You should disable gzip for SSL traffic.
        # See: https://bugs.debian.org/773332
        #
        # Read up on ssl_ciphers to ensure a secure configuration.
        # See: https://bugs.debian.org/765782
        #
        # Self signed certs generated by the ssl-cert package
        # Don't use them in a production server!
        #
        # include snippets/snakeoil.conf;

        root /var/www/html;

        # Add index.php to the list if you are using PHP
        index index.html index.htm index.nginx-debian.html;

        server_name _;

        location / {
                # First attempt to serve request as file, then
                # as directory, then fall back to displaying a 404.
                try_files $uri $uri/ =404;
        }

        # pass PHP scripts to FastCGI server
        #
        #location ~ \.php$ {
        #       include snippets/fastcgi-php.conf;
        #
        #       # With php-fpm (or other unix sockets):
        #       fastcgi_pass unix:/var/run/php/php7.4-fpm.sock;
        #       # With php-cgi (or other tcp sockets):
        #       fastcgi_pass 127.0.0.1:9000;
        #}

        # deny access to .htaccess files, if Apache's document root
        # concurs with nginx's one
        #
        #location ~ /\.ht {
        #       deny all;
        #}
}

# Virtual Host configuration for example.com
#
# You can move that to a different file under sites-available/ and symlink that
# to sites-enabled/ to enable it.
#
#server {
#       listen 80;
#       listen [::]:80;
#
#       server_name example.com;
#
#       root /var/www/example.com;
#       index index.html;
#
#       location / {
#               try_files $uri $uri/ =404;
#       }
#}</code></pre>
<p>이러한 설정파일을 볼 수 있다</p>
<p>이 중</p>
<pre><code class="language-java">root /var/www/html;</code></pre>
<p>이 라인으로 인해서 우리가 흔히 볼 수 있는 nginx 기본 화면을 볼 수 있는 것이다.</p>
<br />

<p>우리가 궁금한건 서버 블락이기 때문에 넘어가면</p>
<pre><code class="language-java">server_name _;
        location /temp{
                root /var/www;
                index temp.html
                try_files $uri $uri/ =404;
        }</code></pre>
<p>임의로 구현해놓은 정적 리소스 호스팅을 위한 코드이다.</p>
<p>/temp로 접근하면 /var/www/temp/temp.html의 파일이 호스팅이 되도록 구현을 해놓은 것이다.</p>
<p>이를 활용하면</p>
<pre><code class="language-java">     location /jaeyeon{
                root /var/www/;
                index temp.html
                try_files $uri $uri/ =404;
        }</code></pre>
<p>이런 식으로 내가 원하는 경로에 정적 리소스를 호스팅 할 수 있게된다.</p>
<hr />
<p><br /><br /></p>
<h1 id="3-리버스-프록시">3. 리버스 프록시</h1>
<p>(리버스 프록시의 필요성, 중요성 등은 다른 포스팅에서 기술하고 구현에 집중하여 기술하겠습니다)</p>
<p>그 다음은 nginx의 꽃, 리버스 프록시를 구현해보자</p>
<p>서버 블록에</p>
<pre><code class="language-java">                proxy_pass http://{IP주소}:{port};
                # First attempt to serve request as file, then
                # as directory, then fall back to displaying a 404.
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</code></pre>
<p>를 추가해주자.</p>
<p>이를 통해 들어오는 80으로 들어오는 요청은 8080으로 전달될 수 있게된다.</p>
<p>이렇게 되면 서버로 들어오는 요청을 nginx가 먼저 수용하게 되고 이를 8080포트로 넘겨주어 서버의 포트번호가 외부로부터 안전 할 수 있게 된다.</p>
<br />
추후 진행되는 green/blue의 경우도 여기서 port 번호를 조정하여 각각의 배포를 조절하기 때문에 이 부분을 알고 넘어가는게 중요하다고 할 수 있다.

<hr />
<h1 id="4-후기">4. 후기</h1>
<p>음.. 적다보니 내용이 다소 부실하다. 느끼는 어려웠던 점을 기술하고 이를 해결하는데에 집중하다보니 내가 겪은 문제점을 토로하는데에 집중해서 그런 것 같다.</p>
<p>ALB와의 상호작용에서 쓸 내용이 많으니 이번엔 조금 용서해주세요…</p>
<p><img alt="" src="https://velog.velcdn.com/images/gdbs1107/post/4ceafdd5-ea3f-4d10-96c2-30ca1e62b3a0/image.png" /></p>
<p><br /><br /><br /><br /><br /><br /><br /><br /></p>
<p><a href="https://velog.io/@mingeloper/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EB%8F%84%EB%A9%94%EC%9D%B8%EA%B3%BC-HTTPS-%EC%84%A4%EC%A0%95%EC%9C%BC%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-Nginx%EC%99%80-ALBAWS-Load-Balancer">https://velog.io/@mingeloper/프로젝트-도메인과-HTTPS-설정으로-배우는-Nginx와-ALBAWS-Load-Balancer</a></p>