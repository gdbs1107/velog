<p><br /><br /></p>
<h1 id="1-들어가며">1. 들어가며</h1>
<p>저번 포스팅에서 nginx를 통한 정적 호스팅과 리버스 프록시를  구현해보았다.</p>
<p>하지만 모름지기 서버라 함은 http로만 통신이 된다면 반쪽짜리라고 할 수 있다. 각종 보안과 브라우저 정책을 이용하는데에 있어서 많은 제한이 있기 때문이다.</p>
<p>그렇기 때문에 우리는 https와 함께 도메인까지 구현하기 위해서 AWS ALB라는 OSI 7계층에서 작동하는 로드밸런서를 붙여줄 필요가 있다.</p>
<p>오늘 해볼 이야기는 ALB와 nginx의 상호작용과 도메인 구축에 대한 내용이다.</p>
<br />

<h3 id="현재-서버상태">현재 서버상태</h3>
<p>현재 서버의 아키텍쳐를 간단하게 요약하면 다음과 같다</p>
<p><img alt="" src="https://velog.velcdn.com/images/gdbs1107/post/38e7d3ae-4d15-4180-b4a7-1918bb28df12/image.png" /></p>
<p>443,80의 요청이 들어오면 요청이 ALB를 통해 8080포트로 전환되어 서버로 전달된다. 동시에 도메인도 처리하고 하는건데…
<br /></p>
<p><strong>일단 명확하지 않다</strong>
<br />
서버자원이 너무 얽히고 섥혀있어 정확히 ALB의 책임이 어디까지 되어있는지 명확하지 않으며 그 책임조차 무슨 책임인지 확실하지 않다.</p>
<p>구현에만 매몰되어 어떻게 동작하는지 모르는 채로 구현한 나의 잘못이 분명한 상황.</p>
<p>난 이렇게 복잡하게 얽힌 아키텍쳐를 가장 먼저 리팩터링하고 싶었다.</p>
<br />

<h3 id="nginx의-부재">NGINX의 부재</h3>
<p>이전 포스팅에서 설명하였듯이, 무중단 배포를 구현한다고 하면 롤링전략을 이용한 Elastic Beanstalk를 이용하여 무중단 배포를 구현 할 수 있었다.</p>
<p>하지만 이미 해당 서버에 설치해놓은 다양한 자원들과 매핑해놓은 것들을 모두 EB에 맞추어 리팩터링하려면 상당한 시간과 노력이 필요하였고 무엇보다..</p>
<p><img alt="" src="https://velog.velcdn.com/images/gdbs1107/post/e435d5ab-0e3d-429d-b139-3a6eeb07e7bb/image.png" /></p>
<p>EB는 한 번 해봐서 또 하기 싫다. 다른거 해보고 싶었다. green/blue로 하면 서버의 자원을 유지한 채로 nginx만을 이용하여 구현 할 수 있기 때문에 유리한 것도 있지만 말이다.</p>
<p>그래서 green/blue로 전환하려고 했지만 대부분의 참고자료가 nginx를 이용하여 green/blue를 구현하고 있었다. 동적으로 리버스 프록시 되는 포트번호를 조절 할 수 있기 때문이라고 생각한다.</p>
<p>그렇기 때문에 nginx가 필요했지만 현재 nginx가 없기 때문에 이를 추가할 필요가 있었다.</p>
<hr />
<p><br /><br /></p>
<h1 id="2-리팩터링">2. 리팩터링</h1>
<p>그래서 결론적으로 어떻게 리팩터링이 진행되냐면</p>
<blockquote>
<p>ALB - Domain연결, https 구현, 80포트로의 전환</p>
</blockquote>
<blockquote>
<p>NGINX - 정적자원 호스팅, 8080으로의 리버스 프록시</p>
</blockquote>
<p>이렇게 역할을 분배하여 구현을 해보았다.</p>
<p><img alt="" src="https://velog.velcdn.com/images/gdbs1107/post/479c026f-c1f8-4157-9133-04eb6fa94bba/image.png" /></p>
<p>이렇게 분배한 근거로는 https 인증서의 처리 방식이 가장 큰 역할을 하였다.</p>
<p>nginx에서 https를 처리하기 위해서는 SSL 인증서가 필요한데, 이는 주기적으로 nginx에 갱신을 해주어야 처리가 가능한 부분으로서 효율성이 떨어진다고 생각하였다.</p>
<p>하지만 ALB의 경우 Route53에서 등록한 도메인을 이용해 ACM에서 인증서를 발급받아 alias로 적용해 놓는다면 다음부터는 인증서 갱신의 필요성이 떨어지기 때문에 nginx로 관리하는 것보다 간편하다고 판단하였다.</p>
<br />

<p>이렇게 구현하게 되면 ALB에서는 443,80 포트를 리스너를 통해 전달받아서</p>
<p>443 → 인증서를 통과 한 후 서버로</p>
<p>80 → 443으로 리다이렉트</p>
<p>되어 두 요청 모두 정상적으로 https로서 서버에 전달 될 수 있다</p>
<br />

<p>결과적으로 ALB가 도메인과 https를 구현하는 역할을 하기 때문에 최종적으로 서버로 요청이 전달되는 역할만 nginx가 맡게 되었다.</p>
<p>이를 이렇게 분배한 이유에는 추후 green/blue 배포로의 확장을 고려하였기 때문 또한 존재한다.</p>
<p>들어온 요청을 green서버로 배포할지, blue서버로 배포할지를 결정하는 역할을 nginx에게 부여하기 위해서 nginx에서 구현되는 역할을 최소화 한 것이다.</p>
<br />

<p>이렇게 되면 nginx와 ALB의 책임을 분리한 결과, 서버로의 문제가 발생 했을 때 어느 부분을 우선적으로 점검해야하는지 파악이 용이해졌다.</p>
<p>또한 해결과정 역시 정확히 예상한대로 구현되는 로직이기 때문에, 예상치 못한 요소로 인한 에러를 방지 할 수 있었다.</p>
<hr />
<p><br /><br /></p>
<h1 id="3정리-및-문제점---여전히-grafana의-경우-ip로만-접속이-가능하다">3.정리 및 문제점 - 여전히 grafana의 경우 IP로만 접속이 가능하다</h1>
<p>구현이 잘 된 것 같지만 현재의 상황에서도 문제점이 존재한다</p>
<p>https://{도메인}:3000 으로 접속을 했을 시 grafana에 접속이 불가능하고</p>
<p>http://{IP주소}:3000 로 접속을 하면 접속이 가능하다</p>
<p>이게 이렇게 되는 이유를 고찰해보자면</p>
<br />

<p>우선 현재 구조에서는 IP로 서버에 접근하는 경우는 ALB를 거치지 않는다.</p>
<p>ALB는 도메인을 기준으로 요청을 잡아 https 등의 처리를 해서 넘기는데, 서버의 IP주소로 직접 접근하는 방식으로 하면 당연히도 해당 요청은 ALB에게 포착되지 않는다.</p>
<br />

<p>이 결과 IP로 접근은 되고, 도메인으로의 접근이 안된다는건</p>
<p><strong>= ALB를 거치지 않으면 접근이 가능하고, DNS를 통해 ALB를 거치는 순간 접근이 불가능해진다는 것이다.</strong></p>
<p>결론적으로 ALB에서 무언가 의도에 맞지 않게 구현되었다는 것이라 ALB의 리스너 문제일 것이라고 생각하여</p>
<p>3000 포트의 리스너를 개방하여 443으로 리다이렉트 되도록 기능을 수정해보았지만 정상적으로 해결되지 않았다. 
이는 앞으로 공부를 더 하면서 해결해 나가야 할 것 같다.</p>
<p><br /><br /><br /><br /><br /></p>
<p><img alt="" src="https://velog.velcdn.com/images/gdbs1107/post/0c840316-717b-43d8-9da6-1dac8d75ecd0/image.png" /></p>
<p>다음 편은 green/blue 리팩터링...</p>